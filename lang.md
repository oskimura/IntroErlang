# 一般的なコンパイル過程

一般的にコンパイラは
1. 字句解析
1. 構文解析
1. 意味解析
1. 最適化
1. コード生成

という順番でコンパイルを行います。
3,4は行われなかったり更に細分化されている場合もありますが、だいたいこのような順序です。
字句解析とはプログラムソースをトークンごとに分解する作業です。
構文解析とは分解されたトークンから構文木を生成する作業です。
意味解析とは構文木から「意味的」なルールを生成したりチェックをしたりします。タイプチェックやスコープの検査が含まれます。
最適化はより効率の良いコードを生成するための最適化を行います。
コード生成は対象のマシンで実行されるコードを生成します。対象のマシンはx86などのネイティブ環境のこともあれば、JavaVMのように仮想マシンのこともあります。
Persecや手書きで再帰下降構文解析を書く方法もありますが、今回は取り上げません。



## 字句解析
プログラムソースからトークを切り出す字句解析ですが、ふつうは字句解析ツールと呼ばれるものを使用することが多いです。
字句解析ツールにはCに対応したflexなどがあり、メジャーな言語にはそれぞれ対応した字句解析ツールがあります。
手書きで書いてもよいのですが、特に理由がない限り字句解析ツールを使うのが時間の節約になります。
字句解析で解析するためには正規表現で文法を書きます。基本的にはPerlなどの正規表現とかわりません。
### flex

## 構文解析
字句解析が終り出力されたものを構文解析をして構文木を生成することになります。
### 構文木
構文木とはプログラムソースを木状のデータ構造で表現したもので、定義された文法を元に生成される。

これも、構文解析ツールを使うのが一般的です。
字句解析ツールから構文解析ツールが受け取れる形式は決まっており、もし手書きで字句解析をおこなったのなら、それぞれのツールの形式に合わせる必要があります。
### BNF
プログラムの文法はBackus Naur form(以下BNF)または拡張されたEBNFで記述するのが一般的です。本文書では特に断りがないかぎりBNFもEBNFもBNFと呼びます。
構文解析ツールの多くはこのBNFを記述するための言語を記述することによりプログラム言語の文法を記述します。
BNFは木のように再帰的な構造を持った文法を記述するのに向いた形式となっています。

構文解析ツールも各言語ごとに対応したものがあるのが普通でCの場合はYACCとよばれるツールを利用します。
なお、ツールが採用しているアルゴリズムは、ツールにより異なります。
#### 終端記号と非終端記号
構文木は大きく分けて終端記号と非終端記号という二種類の要素があります。
終端記号とは木の葉にあたり、非終端記号は木の枝にあたります。
非終端記号の中でも木の根に当たるものを開始記号と呼びます。

終端記号は、変数や数字といった具体的なトークンとなります。
非終端記号は関数やif文というより抽象度の高い式や文といったものになります。
たとえばCで

````
while (1)
{
    func();
}
````
みたいなプログラムがあった場合While文や関数呼び出し式は非終端記号でwhileや1とかfuncなどは終端記号となります。
終端記号の定義は字句解析ツールで行います。なので構文木解析ツールは字句解析ツールから終端記号の情報を教えてもらいます。

### YACC


## 意味解析
意味解析は構文解析ツールが生成した構文木から意味ルールの生成やタイプチェックなどの検査を行います。
## 最適化
最適はコードの使用メモリや使用CPU時間を最小化するために行われます。最適化は構文木に対して行われるものと、機械語に対しておこなわれるものに大きく分類される。
## コード生成
コード生成はターゲットとなるCPUやVMなどで実際に動作可能なコードを生成する。そのため対象のアーキテクチャに依存する。
